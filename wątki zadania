zmiast w tablicy dodawac wszystkie elementy tablicy n 
robimy 4 wątki na 4 rdzeniach ktore osobno beda dodwac liczby ina koncu sie je zsumuje 
#CPU=4 - tyle ile rdzeni tyle daj wątków (mniej wiecej)
dzielimy na tyle ile sie da i ten kto pierwszy skonczy bierze nastepny watek do liczenia 



ZAD 1.(3.0)
psum.c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>

int *A;          // Tablica główna, której elementy będą sumowane
long *res;       // Tablica wyników dla poszczególnych wątków
int n, k;        // n: rozmiar pojedynczej podtablicy, k: liczba podtablic (i wątków)

// Funkcja wykonywana przez każdy wątek
void *worker(void *arg) {
    int id = *(int*)arg;        // Pobranie identyfikatora wątku
    long sum = 0;               // Zmienna do przechowywania sumy dla danego wątku
    int start = id * n;         // Indeks startowy podtablicy dla danego wątku
    int end = start + n;        // Indeks końcowy podtablicy dla danego wątku

    // Sumowanie elementów w przypisanej podtablicy
    for (int i = start; i < end; i++)
        sum += A[i];

    res[id] = sum;              // Zapisanie wyniku do tablicy wyników
    return NULL;
}

int main(int argc, char **argv) {
    // Sprawdzenie, czy podano poprawną liczbę argumentów
    if (argc != 4) {
        printf("Użycie: %s <n> <k> <t>\n", argv[0]);
        return 1;
    }

    n = atoi(argv[1]);          // Rozmiar pojedynczej podtablicy
    k = atoi(argv[2]);          // Liczba podtablic (i wątków)
    int t = atoi(argv[3]);      // Liczba wątków (powinna być równa k)

    int size = n * k;           // Całkowity rozmiar tablicy A
    A = malloc(size * sizeof(int));  // Alokacja pamięci dla tablicy A
    res = calloc(k, sizeof(long));  // Alokacja i wyzerowanie pamięci dla tablicy wyników

    srand(time(NULL));          // Inicjalizacja generatora liczb losowych

    // Wypełnienie tablicy A losowymi wartościami z zakresu 0-9
    for (int i = 0; i < size; i++)
        A[i] = rand() % 10;

    // Obliczenie sumy sekwencyjnie (dla porównania)
    long seq = 0;
    for (int i = 0; i < size; i++)
        seq += A[i];
    printf("Suma sekwencyjna: %ld\n", seq);

    // Tworzenie wątków
    pthread_t threads[k];       // Tablica identyfikatorów wątków
    int ids[k];                 // Tablica identyfikatorów dla wątków

    // Tworzenie wątków i przypisywanie im zadań
    for (int i = 0; i < k; i++) {
        ids[i] = i;                     // Przypisanie identyfikatora wątkowi
        pthread_create(&threads[i], NULL, (void *(*)(void *))worker, &ids[i]);
    }

    // Oczekiwanie na zakończenie wszystkich wątków
    for (int i = 0; i < k; i++)
        pthread_join(threads[i], NULL);

    // Sumowanie wyników z poszczególnych wątków
    long total = 0;
    for (int i = 0; i < k; i++)
        total += res[i];

    printf("Suma wielowątkowa: %ld\n", total);

    // Zwolnienie zaalokowanej pamięci
    free(A);
    free(res);

    return 0;
}


ZAD2 (4.0)#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/time.h>   // zamiast <time.h>

int *A;          // tablica główna
long *res;       // wyniki dla wątków
int n, k;        // rozmiar podtablicy i liczba bloków

void* worker(void *arg) {
    int id = *(int*)arg;
    long sum = 0;

    int start = id * n;
    int end = start + n;

    for (int i = start; i < end; i++)
        sum += A[i];

    res[id] = sum;
    return NULL;
}

long long czas_us() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (long long)tv.tv_sec * 1000000 + tv.tv_usec;
}

int main(int argc, char **argv) {

    if (argc != 4) {
        printf("Użycie: %s <n> <k> <t>\n", argv[0]);
        return 1;
    }

    n = atoi(argv[1]);
    k = atoi(argv[2]);
    int t = atoi(argv[3]);   // liczba wątków = liczba podtablic

    int size = n * k;

    A = malloc(size * sizeof(int));
    res = calloc(k, sizeof(long));

    srand(time(NULL));

    for (int i = 0; i < size; i++)
        A[i] = rand() % 10;

    // --- suma sekwencyjna ---
    long long start_seq = czas_us();
    long seq = 0;
    for (int i = 0; i < size; i++)
        seq += A[i];
    long long end_seq = czas_us();

    printf("Suma sekwencyjna: %ld   czas = %lld us\n", seq, end_seq - start_seq);

    // --- wątki ---
    pthread_t threads[k];
    int ids[k];

    long long start_par = czas_us();
    for (int i = 0; i < k; i++) {
        ids[i] = i;
        pthread_create(&threads[i], NULL, worker, &ids[i]);
    }
    for (int i = 0; i < k; i++)
        pthread_join(threads[i], NULL);

    long total = 0;
    for (int i = 0; i < k; i++)
        total += res[i];
    long long end_par = czas_us();

    printf("Suma wielowątkowa: %ld   czas = %lld us\n", total, end_par - start_par);

    free(A);
    free(res);
    return 0;
}


Zad3. (5.0)
long best_time = LONG_MAX;
int best_n, best_k, best_t;

for (int n = 1; n <= m; n++) {
    if (m % n != 0) continue;
    int k = m / n;
    for (int t = 1; t <= max_threads; t++) {
        double czas = czas_wykonania(n, k, t); // funkcja zwraca czas sumowania równoległego
        if (czas < best_time) {
            best_time = czas;
            best_n = n;
            best_k = k;
            best_t = t;
        }
    }
}

printf("Najlepsza konfiguracja: n=%d, k=%d, t=%d, czas=%.6f s\n", best_n, best_k, best_t, best_time);

?????????????????????????????????????????????????????????????????????????????????????????????????????????
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/time.h>

int *A;          
long *res;       

int n, k;       

void* worker(void *arg) {
    int id = *(int*)arg;
    long sum = 0;

    int start = id * n;
    int end = start + n;

    for (int i = start; i < end; i++)
        sum += A[i];

    res[id] = sum;
    return NULL;
}

long long czas_us() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (long long)tv.tv_sec * 1000000 + tv.tv_usec;
}

int main(int argc, char **argv) {

    if (argc != 2) {
        printf("Użycie: %s <m>\n", argv[0]);
        return 1;
    }

    int m = atoi(argv[1]);  // liczba wszystkich elementów

    srand(time(NULL));

    // Wygeneruj tablicę
    A = malloc(m * sizeof(int));
    for (int i = 0; i < m; i++)
        A[i] = rand() % 10;

    long long best_time = 1LL << 60;
    int best_n = 0, best_k = 0, best_t = 0;

    // testujemy wszystkie dzielniki m jako możliwe n
    for (int test_n = 1; test_n <= m; test_n++) {
        if (m % test_n != 0) continue;
        int test_k = m / test_n;

        // testujemy liczby wątków od 1 do test_k
        for (int test_t = 1; test_t <= test_k; test_t++) {
            res = calloc(test_k, sizeof(long));
            pthread_t threads[test_k];
            int ids[test_k];

            long long start_par = czas_us();

            for (int i = 0; i < test_k; i++) {
                ids[i] = i;
                pthread_create(&threads[i], NULL, worker, &ids[i]);
            }
            for (int i = 0; i < test_k; i++)
                pthread_join(threads[i], NULL);

            long long end_par = czas_us();
            long long czas = end_par - start_par;

            if (czas < best_time) {
                best_time = czas;
                best_n = test_n;
                best_k = test_k;
                best_t = test_t;
            }

            free(res);
        }
    }

    printf("Optymalne parametry dla m=%d:\n", m);
    printf("n = %d, k = %d, t = %d\n", best_n, best_k, best_t);
    printf("Minimalny czas = %lld us\n", best_time);

    free(A);
    return 0;
}
???????????????????????????????????????????????????????????????????????????????????????????????????????????




najwolniejsza operacja w math.h to 
double a,b,c 
wylosuj a b c
c= sin /cos/ tg/ albo pierwiastek / albo pow(a,b)*a*b

ZROBIC WYKRES DO 4
